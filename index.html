<!doctype html>
<html>
    <head>
        <title>Car Model</title>
        <meta charset="utf-8"/>
<style>
canvas {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
}
</style>
    </head>
    <body>
        <canvas width="600" height="600"></canvas>
        <script>
/* Rotations */
function rot(x, y, t)
{
    var tt = Math.atan(y/x);
    var tl = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    if (x < 0) tt += Math.PI;
    return [Math.cos(tt + t) * tl, Math.sin(tt + t) * tl];
}

/* Intersections */
function isect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2)
{
    var ix, iy;

    /* Both lines are verticals, not intersecting */
    if ((Ax1 == Ax2) && (Bx1 == Bx2))
    {
        return undefined;
    }

    /* First line is vertical */
    if (Ax1 == Ax2)
    {
        var k2 = (By2 - By1) / (Bx2 - Bx1);
        var b2 = By1 - (k2 * Bx1);
        ix = Ax1;
        iy = k2*ix + b2;
    }
    /* Second line is vertical */
    else if (Bx1 == Bx2)
    {
        var k1 = (Ay2 - Ay1) / (Ax2 - Ax1);
        var b1 = Ay1 - (k1 * Ax1);
        ix = Bx1;
        iy = k1*ix + b1;
    }
    else
    {
        /* Calculate line coefficients */
        var k1 = (Ay2 - Ay1) / (Ax2 - Ax1);
        var k2 = (By2 - By1) / (Bx2 - Bx1);

        /* If lines are parallel, they do not intersect */
        if (k1 == k2) return undefined;

        /* Calculate shifts */
        var b1 = Ay1 - (k1 * Ax1);
        var b2 = By1 - (k2 * Bx1);

        /*  Find the intersection point
            y = K1x + B1
            y = K2x + B2
            -->
            x = (y - B2) / K2
            y = (K2B1 - K1B2) / (K2 - K1)
            -->
            x = (y - B1) / K1
            y = (K1B2 - K2B1) / (K1 - K2)
        */
        if (k2 == 0)
        {
            iy = (k1*b2 - k2*b1) / (k1 - k2);
            ix = (iy - b1) / k1;
        }
        else
        {
            iy = (k2*b1 - k1*b2) / (k2 - k1);
            ix = (iy - b2) / k2;
        }
        
    }

    /* Check if point lies in the short ranges */
    if ((ix > Math.max(Ax1, Ax2)) || (ix < Math.min(Ax1, Ax2))
        || (iy > Math.max(Ay1, Ay2)) || (iy < Math.min(Ay1, Ay2))
        || (ix > Math.max(Bx1, Bx2)) || (ix < Math.min(Bx1, Bx2))
        || (iy > Math.max(By1, By2)) || (iy < Math.min(By1, By2)))
    {
        return undefined;
    }

    return [ix, iy];
}

/* Geometrics */
var Mesh = function(color)
{
    this.points = [];
    this.x = 0;
    this.y = 0;
    this.theta = 0;
    this.solid = true;
    this.color = (color != undefined) ? color : "#eee";

    this.translate = function(x, y)
    {
        this.x += x;
        this.y += y;

        for (var i in this.points)
        {
            this.points[i][0] += x;
            this.points[i][1] += y;
        }
    }

    this.rotate = function(theta)
    {
        this.theta += theta;

        for (var i in this.points)
        {
            var tmp = rot(this.points[i][0], this.points[i][1], theta);
            this.points[i] = tmp;
        }
    }

    this.add_point = function(point)
    {
        var tmp = rot(point[0], point[1], this.theta);
        tmp[0] += this.x;
        tmp[1] += this.y;
        this.points.push(tmp);
    }

    this.colliding = function(mesh)
    {
        var isp = [];

        if ((!this.solid) || (!mesh.solid))
        {
            return undefined;
        }

        for (var i = 1; i < this.points.length; i++)
        {
            var p11 = this.points[i-1];
            var p12 = this.points[i];
            for (var j = 1; j < mesh.points.length; j++)
            {
                var p21 = mesh.points[j-1];
                var p22 = mesh.points[j];
                p = isect(p11[0], p11[1], p12[0], p12[1],
                          p21[0], p21[1], p22[0], p22[1]);
                if (p != undefined)
                {
                    isp.push(p);
                }
            }
        }

        return (isp.length == 0) ? undefined : isp;
    }

    this.render = function(canvas)
    {
        var ctx = canvas.getContext("2d");

        if (this.points.length > 0)
        {
            ctx.beginPath();
            ctx.strokeStyle = this.color;
            ctx.font = "10px courier";
            ctx.moveTo(this.points[0][0], this.points[0][1]);

            for (var i = 1; i < this.points.length; i++)
            {
                ctx.lineTo(this.points[i][0], this.points[i][1]);
            }

            ctx.stroke();
        }
    }
}

var Group = function()
{
    this.meshes = [];
    this.x = 0;
    this.y = 0;
    this.theta = 0;

    this.translate = function(x, y)
    {
        this.x += x;
        this.y += y;

        for (var i in this.meshes)
        {
            this.meshes[i].translate(x, y);
        }
    }

    this.rotate = function(theta)
    {
        this.theta += theta;
        
        for (var i in this.meshes)
        {
            this.meshes[i].rotate(theta);
        }
    }

    this.add_mesh = function(mesh)
    {
        mesh.rotate(this.theta);
        mesh.translate(this.x, this.y);
        this.meshes.push(mesh);
    }

    this.colliding = function(group)
    {
        var isp = [];

        for (var i in this.meshes)
        {
            for (var j in group.meshes)
            {
                var ps = this.meshes[i].colliding(group.meshes[j]);

                if (ps != undefined)
                {
                    isp = isp.concat(ps);
                }
            }
        }

        return (isp.length == 0) ? undefined : isp;
    }

    this.render = function(canvas)
    {   
        for (var i in this.meshes)
        {
            this.meshes[i].render(canvas);
        }
    }
}

var Ray = function(x, y, theta, len)
{
    this.x = x;
    this.y = y;
    this.theta = theta;
    this.max_len = len;

    this.translate = function(x, y)
    {
        this.x += x;
        this.y += y;
    }

    this.rotate = function(theta)
    {
        var temp = rot(this.x, this.y, theta);
        this.x = temp[0];
        this.y = temp[1];
        this.theta += theta;
    }
    
    this.nearest_encounter = function(group)
    {
        var nx = this.x + (this.max_len * Math.cos(this.theta));
        var ny = this.y + (this.max_len * Math.sin(this.theta));
        var nl = null;
        var np = null;

        /* Find nearest intersection */
        var tmp = new Mesh();
        var gtmp = new Group();
        tmp.add_point([this.x, this.y]);
        tmp.add_point([nx, ny]);
        gtmp.add_mesh(tmp);
        var isp = gtmp.colliding(group);

        if (isp == undefined)
        {
            return [nx, ny];
        }

        for (var i in isp)
        {
            var tl = Math.sqrt(Math.pow((isp[i][0] - this.x), 2)
                             + Math.pow((isp[i][1] - this.y), 2));

            if ((nl == null) || (tl < nl))
            {
                nl = tl;
                np = isp[i];
            }
        }

        if (np != null)
        {
            return np;
        }

        return [nx, ny];
    }

    this.get_distance = function(group)
    {
        var p = this.nearest_encounter(group);

        return Math.sqrt(Math.pow(p[0]-this.x, 2)
                       + Math.pow(p[1]-this.y, 2));
    }

    this.render = function(canvas, group)
    {
        var ctx = canvas.getContext("2d");

        var p = this.nearest_encounter(group);
        var d = Math.floor(Math.sqrt(Math.pow(p[0]-this.x, 2)
                                   + Math.pow(p[1]-this.y, 2)));

        ctx.fillStyle = "#f00";
        ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
        ctx.strokeStyle = "#f00";
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(p[0], p[1]);
        ctx.stroke();
        ctx.font = "10px arial";
        ctx.fillText(d, (p[0]-this.x)/2+this.x,
                        (p[1]-this.y)/2+this.y);
    }
}

/** Models **/
var Car = function(x, y, theta, col)
{
    this.x = x;
    this.y = y;
    this.theta = theta;
    this.speed = 0;

    this.sens_fl = new Ray(10, -20, -Math.PI*3/4, 150);
    this.sens_fr = new Ray(-10, -20, -Math.PI/4, 150);
    this.sens_sl = new Ray(-10, -5, -Math.PI, 150);
    this.sens_sr = new Ray(10, -5, 0, 150);
    this.mesh = new Mesh(col);

    this.sens_fl.rotate(this.theta);
    this.sens_fl.translate(this.x, this.y);
    this.sens_fr.rotate(this.theta);
    this.sens_fr.translate(this.x, this.y);
    this.sens_sl.rotate(this.theta);
    this.sens_sl.translate(this.x, this.y);
    this.sens_sr.rotate(this.theta);
    this.sens_sr.translate(this.x, this.y);
    this.mesh.add_point([-10, -20]);
    this.mesh.add_point([10, -20]);
    this.mesh.add_point([10, 20]);
    this.mesh.add_point([-10, 20]);
    this.mesh.add_point([-10, -20]);
    this.mesh.rotate(this.theta);
    this.mesh.translate(this.x, this.y);

    this.move = function()
    {
        if (this.speed == 0) return;
        var p = rot(0, this.speed, this.theta);
        this.mesh.translate(p[0], p[1]);
        this.sens_fl.translate(p[0], p[1]);
        this.sens_fr.translate(p[0], p[1]);
        this.sens_sl.translate(p[0], p[1]);
        this.sens_sr.translate(p[0], p[1]);
        this.x += p[0];
        this.y += p[1];
    }

    this.go_forward = function()
    {
        if (this.speed <= 0)
        {
            this.speed = -2;
        }
        else
        {
            this.speed = 0;
        }
    }

    this.go_backward = function()
    {
        if (this.speed >= 0)
        {
            this.speed = 2;
        }
        else
        {
            this.speed = 0;
        }
    }
    
    this.rotate = function(theta)
    {
        this.mesh.translate(-this.x, -this.y);
        this.sens_fl.translate(-this.x, -this.y);
        this.sens_fr.translate(-this.x, -this.y);
        this.sens_sl.translate(-this.x, -this.y);
        this.sens_sr.translate(-this.x, -this.y);

        this.mesh.rotate(theta);
        this.sens_fl.rotate(theta);
        this.sens_fr.rotate(theta);
        this.sens_sl.rotate(theta);
        this.sens_sr.rotate(theta);

        this.mesh.translate(this.x, this.y);
        this.sens_fl.translate(this.x, this.y);
        this.sens_fr.translate(this.x, this.y);
        this.sens_sl.translate(this.x, this.y);
        this.sens_sr.translate(this.x, this.y);

        this.theta += theta;
    }

    this.turn_left = function()
    {
        this.rotate(-Math.PI/90);        
    }

    this.turn_right = function()
    {
        this.rotate(Math.PI/90);
    }
    
    this.render = function(canvas, group)
    {
        this.sens_fl.render(canvas, group);
        this.sens_fr.render(canvas, group);
        this.sens_sl.render(canvas, group);
        this.sens_sr.render(canvas, group);
        this.mesh.render(canvas);
    }

    this.update = function(group)
    {
        var dist_fl = this.sens_fl.get_distance(group);
        var dist_fr = this.sens_fr.get_distance(group);
        var dist_sl = this.sens_sl.get_distance(group);
        var dist_sr = this.sens_sr.get_distance(group);

        if ((dist_fl < 40) && (dist_fr < 40))
        {
            this.go_backward();
            this.go_backward();
            if (dist_sl > dist_sr)
            {
                this.turn_left();
            }
            else
            {
                this.turn_right();
            }
        }
        else
        {
            this.go_forward();
            this.go_forward();
            if (dist_fl > dist_fr)
            {
                this.turn_left();
            }
            else
            {
                this.turn_right();
            }
        }
    }
}

var cv = document.getElementsByTagName("canvas")[0];
var cx = cv.getContext("2d");

var player1 = new Car(450, 240, Math.PI/20, "#3ff");
var player2 = new Car(490, 240, Math.PI/20, "#f3f");
var player3 = new Car(440, 300, Math.PI/17, "#ff3");
var player4 = new Car(480, 300, Math.PI/19, "#33f");
var player5 = new Car(430, 360, Math.PI/20, "#f33");
var player6 = new Car(470, 360, Math.PI/18, "#aaa");

var track1 = new Mesh("#fff");
track1.add_point([90, 100]);
track1.add_point([550, 90]);
track1.add_point([500, 480]);
track1.add_point([100, 440]);
track1.add_point([90, 100]);

var track2 = new Mesh("#fff");
track1.add_point([190, 200]);
track1.add_point([430, 200]);
track1.add_point([400, 380]);
track1.add_point([200, 370]);
track1.add_point([190, 200]);

var scene = new Group();
scene.add_mesh(track1);
scene.add_mesh(track2);

var manual = true;
window.onkeypress = function(e)
{
    switch (e.which)
    {
        case 119: //up (W)
        case 87:
            player1.go_forward();
            break;
        case 97:  //left (A)
        case 65:
            player1.turn_left();
            break;
        case 100: //right (D)
        case 68:
            player1.turn_right();
            break;
        case 115: //down (S)
        case 83:
            player1.go_backward();
            break;
        case 32:
            manual = false;
            window.setInterval(function() {
                player1.update(scene);
                player2.update(scene);
                player3.update(scene);
                player4.update(scene);
                player5.update(scene);
                player6.update(scene);
            }, 40);
            break;
    }
}

/* Render loop */
window.setInterval(function() {
    player1.move();
    player2.move();
    player3.move();
    player4.move();
    player5.move();
    player6.move();

    cx.fillStyle = "#444";
    cx.fillRect(0, 0, cv.width, cv.height);

    scene.render(cv);
    player1.render(cv, scene);
    //player2.render(cv, scene);
    //player3.render(cv, scene);
    //player4.render(cv, scene);
    //player5.render(cv, scene);
    //player6.render(cv, scene);

    cx.fillStyle = "#fff";
    cx.font = "32px verdana";
    cx.fillText(manual?"Manual":"Automatic", 10, 50);
}, 20);
        </script>
    </body>
</html>
